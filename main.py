import os
import base64
import aiohttp
import sqlite3
import telegram
import logging
import asyncio
from collections import deque
from telegram import Update, File
from telegram.ext import (
    Application, CommandHandler, MessageHandler,
    filters, CallbackContext, ConversationHandler
)
import google.generativeai as genai

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
TOKEN = os.getenv("TOKEN")
GOOGLE_API_KEY = os.getenv("GEMINI_API_KEY")

if not TOKEN or not GOOGLE_API_KEY:
    raise ValueError("–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç —Ç–æ–∫–µ–Ω Telegram –∏–ª–∏ Google Gemini API.")

genai.configure(api_key=GOOGLE_API_KEY)
model = genai.GenerativeModel("gemini-2.0-flash")

user_histories = {}
user_profiles = {}
MAX_HISTORY_LENGTH = 5

(
    ASK_NAME, ASK_GENDER, ASK_AGE, ASK_WEIGHT, ASK_GOAL,
    ASK_ACTIVITY, ASK_DIET_PREF, ASK_HEALTH, ASK_EQUIPMENT, ASK_TARGET
) = range(10)

def init_db():
    conn = sqlite3.connect("users.db")
    cursor = conn.cursor()
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS user_profiles (
        user_id INTEGER PRIMARY KEY,
        name TEXT,
        gender TEXT,
        age INTEGER,
        weight REAL,
        goal TEXT,
        activity TEXT,
        diet TEXT,
        health TEXT,
        equipment TEXT,
        target_metric TEXT
    )
    ''')
    conn.commit()
    conn.close()

def save_user_profile(user_id: int, profile: dict):
    conn = sqlite3.connect("users.db")
    cursor = conn.cursor()
    cursor.execute('''
    INSERT OR REPLACE INTO user_profiles
    (user_id, name, gender, age, weight, goal, activity, diet, health, equipment, target_metric)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ''', (
        user_id,
        profile.get("name"),
        profile.get("gender"),
        profile.get("age"),
        profile.get("weight"),
        profile.get("goal"),
        profile.get("activity"),
        profile.get("diet"),
        profile.get("health"),
        profile.get("equipment"),
        profile.get("target_metric"),
    ))
    conn.commit()
    conn.close()

async def download_and_encode(file: File, context: CallbackContext) -> dict:
    telegram_file = await file.get_file()
    async with aiohttp.ClientSession() as session:
        async with session.get(telegram_file.file_path) as resp:
            data = await resp.read()
    mime_type = "image/jpeg"
    return {
        "inline_data": {
            "mime_type": mime_type,
            "data": base64.b64encode(data).decode("utf-8"),
        }
    }

async def start(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text("–ü—Ä–∏–≤–µ—Ç! –Ø —Ç–≤–æ–π –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π —Ñ–∏—Ç–Ω–µ—Å-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç NutriBot. –ö–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç?")
    return ASK_NAME

async def ask_gender(update: Update, context: CallbackContext) -> int:
    user_id = update.message.from_user.id
    user_profiles[user_id] = {"name": update.message.text}
    await update.message.reply_text("–£–∫–∞–∂–∏ —Å–≤–æ–π –ø–æ–ª (–º/–∂):")
    return ASK_GENDER

async def ask_age(update: Update, context: CallbackContext) -> int:
    gender = update.message.text.lower()
    if gender not in ["–º", "–∂"]:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏ —Ç–æ–ª—å–∫–æ '–º' –∏–ª–∏ '–∂'.")
        return ASK_GENDER
    user_profiles[update.message.from_user.id]["gender"] = gender
    await update.message.reply_text("–°–∫–æ–ª—å–∫–æ —Ç–µ–±–µ –ª–µ—Ç?")
    return ASK_AGE

async def ask_weight(update: Update, context: CallbackContext) -> int:
    try:
        age = int(update.message.text)
    except ValueError:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏ –≤–æ–∑—Ä–∞—Å—Ç —á–∏—Å–ª–æ–º.")
        return ASK_AGE
    user_profiles[update.message.from_user.id]["age"] = age
    await update.message.reply_text("–ö–∞–∫–æ–π —É —Ç–µ–±—è —Ç–µ–∫—É—â–∏–π –≤–µ—Å (–≤ –∫–≥)?")
    return ASK_WEIGHT

async def ask_goal(update: Update, context: CallbackContext) -> int:
    try:
        weight = float(update.message.text.replace(",", "."))
    except ValueError:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏ –≤–µ—Å —á–∏—Å–ª–æ–º.")
        return ASK_WEIGHT
    user_profiles[update.message.from_user.id]["weight"] = weight
    await update.message.reply_text("–ö–∞–∫–∞—è —É —Ç–µ–±—è —Ü–µ–ª—å? (–ü–æ—Ö—É–¥–µ—Ç—å, –ù–∞–±—Ä–∞—Ç—å –º–∞—Å—Å—É, –†–µ–ª—å–µ—Ñ, –ü—Ä–æ—Å—Ç–æ –ó–û–ñ)")
    return ASK_GOAL

async def ask_activity(update: Update, context: CallbackContext) -> int:
    user_profiles[update.message.from_user.id]["goal"] = update.message.text
    await update.message.reply_text("–ö–∞–∫–æ–π —É —Ç–µ–±—è —É—Ä–æ–≤–µ–Ω—å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏? (–ù–æ–≤–∏—á–æ–∫, –°—Ä–µ–¥–Ω–∏–π, –ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π)")
    return ASK_ACTIVITY

async def ask_diet_pref(update: Update, context: CallbackContext) -> int:
    user_profiles[update.message.from_user.id]["activity"] = update.message.text
    await update.message.reply_text("–ï—Å—Ç—å –ª–∏ —É —Ç–µ–±—è –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è –≤ –µ–¥–µ? (–≤–µ–≥–∞–Ω—Å—Ç–≤–æ, –∞–ª–ª–µ—Ä–≥–∏–∏ –∏ —Ç.–ø.)")
    return ASK_DIET_PREF

async def ask_health(update: Update, context: CallbackContext) -> int:
    user_profiles[update.message.from_user.id]["diet"] = update.message.text
    await update.message.reply_text("–ï—Å—Ç—å –ª–∏ —É —Ç–µ–±—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–æ –∑–¥–æ—Ä–æ–≤—å—é?")
    return ASK_HEALTH

async def ask_equipment(update: Update, context: CallbackContext) -> int:
    user_profiles[update.message.from_user.id]["health"] = update.message.text
    await update.message.reply_text("–ö–∞–∫–æ–π —É —Ç–µ–±—è –µ—Å—Ç—å –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å/—Ç—Ä–µ–Ω–∞–∂—ë—Ä—ã?")
    return ASK_EQUIPMENT

async def ask_target(update: Update, context: CallbackContext) -> int:
    user_profiles[update.message.from_user.id]["equipment"] = update.message.text
    await update.message.reply_text("–ö–∞–∫–∞—è —É —Ç–µ–±—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∞—è —Ü–µ–ª—å –ø–æ –≤–µ—Å—É –∏–ª–∏ –¥—Ä—É–≥–∏–º –º–µ—Ç—Ä–∏–∫–∞–º?")
    return ASK_TARGET

async def finish_questionnaire(update: Update, context: CallbackContext) -> int:
    user_id = update.message.from_user.id
    user_profiles[user_id]["target_metric"] = update.message.text
    save_user_profile(user_id, user_profiles[user_id])
    await update.message.reply_text("–ê–Ω–∫–µ—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞ üéâ –¢–µ–ø–µ—Ä—å —Ç—ã –º–æ–∂–µ—à—å –ø—Ä–∏—Å—ã–ª–∞—Ç—å –º–Ω–µ —Ñ–æ—Ç–æ –µ–¥—ã, —Ç–µ–∫—Å—Ç –∏ —Ç.–¥. ‚Äî —è –ø–æ–º–æ–≥—É —Å –∞–Ω–∞–ª–∏–∑–æ–º!")
    return ConversationHandler.END

async def show_profile(update: Update, context: CallbackContext) -> None:
    user_id = update.message.from_user.id
    conn = sqlite3.connect("users.db")
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM user_profiles WHERE user_id = ?", (user_id,))
    row = cursor.fetchone()
    conn.close()

    if not row:
        await update.message.reply_text("–ü—Ä–æ—Ñ–∏–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–π–¥–∏ –∞–Ω–∫–µ—Ç—É —Å –ø–æ–º–æ—â—å—é /start.")
        return

    profile_text = (
        f"–¢–≤–æ–π –ø—Ä–æ—Ñ–∏–ª—å:\n\n"
        f"–ò–º—è: {row[1]}\n–ü–æ–ª: {row[2]}\n–í–æ–∑—Ä–∞—Å—Ç: {row[3]}\n–í–µ—Å: {row[4]} –∫–≥\n"
        f"–¶–µ–ª—å: {row[5]}\n–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å: {row[6]}\n–ü–∏—Ç–∞–Ω–∏–µ: {row[7]}\n"
        f"–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è: {row[8]}\n–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å: {row[9]}\n–¶–µ–ª–µ–≤–∞—è –º–µ—Ç—Ä–∏–∫–∞: {row[10]}"
    )
    await update.message.reply_text(profile_text)

async def handle_text(update: Update, context: CallbackContext):
    user_id = update.message.from_user.id
    text = update.message.text
    history = user_histories.setdefault(user_id, deque(maxlen=MAX_HISTORY_LENGTH))
    history.append({"role": "user", "parts": [text]})
    response = model.generate_content(list(history))
    history.append({"role": "model", "parts": [response.text]})
    await update.message.reply_text(response.text)

async def handle_photo(update: Update, context: CallbackContext):
    file = await update.message.photo[-1].get_file()
    image_data = await download_and_encode(file, context)
    prompt = "–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —ç—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è –ø–∏—Ç–∞–Ω–∏—è –∏–ª–∏ —Ñ–∏—Ç–Ω–µ—Å–∞."
    response = model.generate_content([prompt, image_data])
    await update.message.reply_text(response.text)

def main():
    init_db()
    app = Application.builder().token(TOKEN).build()
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            ASK_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_gender)],
            ASK_GENDER: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_age)],
            ASK_AGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_weight)],
            ASK_WEIGHT: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_goal)],
            ASK_GOAL: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_activity)],
            ASK_ACTIVITY: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_diet_pref)],
            ASK_DIET_PREF: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_health)],
            ASK_HEALTH: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_equipment)],
            ASK_EQUIPMENT: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_target)],
            ASK_TARGET: [MessageHandler(filters.TEXT & ~filters.COMMAND, finish_questionnaire)],
        },
        fallbacks=[],
    )

    app.add_handler(conv_handler)
    app.add_handler(CommandHandler("profile", show_profile))
    app.add_handler(MessageHandler(filters.PHOTO, handle_photo))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))

    app.run_polling()

if __name__ == "__main__":
    main()
